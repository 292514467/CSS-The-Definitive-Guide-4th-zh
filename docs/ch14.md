# 第 14 章 CSS 中的表格布局 Table Layout in CSS


You may have glanced at that title and wondered, “Table layout? Isn’t that exactly
what we’re trying to avoid doing?” Indeed so, but this chapter is not about using
tables for layout. Instead, it’s about the ways that tables themselves are laid out by
CSS, which is a far more complicated affair than it might first appear.

Tables are unusual, compared to the rest of document layout. Until flexbox and grid
came along, tables alone possessed the unique ability to associate element sizes with
other elements—for example, all the cells in a row have the same height, no matter
how much or how little content each individual cell might contain. The same is true
for the widths of cells that share a column. Cells that adjoin can share a border, even
if the two cells have very different border styles. As we’ll see, these abilities are pur‐
chased at the expense of a great many behaviors and rules—many of them rooted
deep in the past—that apply to tables, and only tables.



## 14.1 Table Formatting

Before we can start to worry about how cell borders are drawn and tables sized, we
need to delve into the fundamental ways in which tables are assembled, and the ways
that elements within a table are related. This is referred to as table formatting, and it is
quite distinct from table layout: the layout is possible only after the formatting has
been completed.


### 14.1.1 Visually Arranging a Table

The first thing to understand is how CSS defines the arrangement of tables. While
this knowledge may seem a bit basic, it’s key to understanding how best to style
tables.

CSS draws a distinction between table elements and internal table elements. In CSS,
internal table elements generate rectangular boxes that have content, padding, and
borders, but not margins. Therefore, it is not possible to define the separation
between table cells by giving them margins. A CSS-conformant browser will ignore
any attempts to apply margins to cells, rows, or any other internal table element (with
the exception of captions, which are discussed in the “Captions” on page 744).

There are six basic rules for arranging tables. The basis of these rules is a grid cell,
which is one area between the grid lines on which a table is drawn. Consider
Figure 14-1, in which two tables are shown: their grid cells are indicated by the
dashed lines drawn over the tables.


Figure 14-1. Grid cells form the basis of table layout

In a simple 2 × 2 table, such as the lefthand table shown in Figure 14-1, the grid cells
correspond to the actual table cells. In a more complicated table, like the righthand
table in Figure 14-1, some table cells will span multiple grid cells—but note that every
table cell’s edges are placed along a grid-cell edge.

These grid cells are largely theoretical constructs, and they cannot be styled or even
accessed through the Document Object Model (DOM). They just serve as a way to
describe how tables are assembled for styling.

#### Table arrangement rules

- Each row box encompasses a single row of grid cells. All the row boxes in a table
fill the table from top to bottom in the order they occur in the source document
(with the exception of any table-header or table-footer row boxes, which come at
the beginning and end of the table, respectively). Thus, a table contains as many
grid rows as there are row elements (e.g., tr elements).
- A row group’s box encompasses the same grid cells as the row boxes it contains.
- A column box encompasses one or more columns of grid cells. All the column
boxes are placed next to one another in the order they occur. The first column
box is on the left for left-to-right languages, and on the right for right-to-left lan‐
guages.
- A column group’s box encompasses the same grid cells as the column boxes it
contains.
- Although cells may span several rows or columns, CSS does not define how this
happens. It is instead left to the document language to define spanning. Each
spanned cell is a rectangular box one or more grid cells wide and high. The top
row of this spanning rectangle is in the row that is parent to the spanned grid
cell. The cell’s rectangle must be as far to the left as possible in left-to-right lan‐
guages, but it may not overlap any other cell box. It must also be to the right of all
cells in the same row that are earlier in the source document (in a left-to-right
language). In right-to-left languages, a spanned cell must be as far to the right as
possible without overlapping other cells, and must be to the left of all cells in the
same row that follow it in the document source.
- A cell’s box cannot extend beyond the last row box of a table or row group. If the
table structure would cause this condition, the cell must be shortened until it fits
within the table or row group that encloses it.

The CSS specification discourages, but does not prohibit, the posi‐
tioning of table cells and other internal table elements. Positioning
a row that contains row-spanning cells, for example, could dramat‐
ically alter the layout of the table by removing the row from the
table entirely, thus removing the spanned cells from consideration
in the layout of other rows. Nevertheless, it is quite possible to
apply positioning to table elements in current browsers.

By definition, grid cells are rectangular, but they do not all have to be the same size.
All the grid cells in a given grid column will be the same width, and all the grid cells
in a grid row will be the same height, but the height of one grid row may be different
than that of another grid row. Similarly, grid columns may be of different widths.
With those basic rules in mind, a question may arise: how, exactly, do you know
which elements are cells and which are not?


### 14.1.2 Table Display Values

In HTML, it’s easy to know which elements are parts of tables because the handling of
elements like tr and td is built into browsers. In XML, on the other hand, there is no
way to intrinsically know which elements might be part of a table. This is where a
whole collection of values for display come into play.

//

In this chapter, we’ll stick to the table-related values, as the others are all beyond the
scope of tables. The table-related values can be summarized as follows:

table

This value specifies that an element defines a block-level table. Thus, it defines a
rectangular block that generates a block box. The corresponding HTML element
is, not surprisingly, table.

inline-table

This value specifies that an element defines an inline-level table. This means the
element defines a rectangular block that generates an inline box. The closest non-
table analogue is the value inline-block. The closest HTML element is table,
although, by default, HTML tables are not inline.

table-row

This value specifies that an element is a row of table cells. The corresponding
HTML element is the tr element.

table-row-group

This value specifies that an element groups one or more table rows. The corre‐
sponding HTML value is tbody.

table-header-group

This value is very much like table-row-group, except that for visual formatting,
the header row group is always displayed before all other rows and row groups,
and after any top captions. In print, if a table requires multiple pages to print, a
user agent may repeat header rows at the top of each page (Firefox does this, for
example). The specification does not define what happens if you assign tableheader-group to multiple elements. A header group can contain multiple rows.

The HTML equivalent is thead.

table-footer-group

This value is very much like table-header-group, except that the footer row
group is always displayed after all other rows and row groups, and before any
bottom captions. In print, if a table requires multiple pages to print, a user agent
may repeat footer rows at the bottom of each page. The specification does not
define what happens if you assign table-footer-group to multiple elements.
This is equivalent to the HTML element tfoot.

table-column

This value declares that an element describes a column of table cells. In CSS
terms, elements with this display value are not visually rendered, as if they had
the value none. Their existence is largely for the purposes of helping to define the
presentation of cells within the column. The HTML equivalent is the col ele‐
ment.

table-column-group

This value declares that an element groups one or more columns. Like tablecolumn elements, table-column-group elements are not rendered, but the value
is useful for defining presentation for elements within the column group. The
HTML equivalent is the colgroup element.

table-cell

This value specifies that an element represents a single cell in a table. The HTML
elements th and td are both examples of table-cell elements.

table-caption

This value defines a table’s caption. CSS does not define what should happen if
multiple elements have the value caption, but it does explicitly warn, “authors
should not put more than one element with display: caption inside a table or
inline-table element.”

You can get a quick summary of the general effects of these values by taking an
excerpt from the example HTML 4.0 stylesheet given in Appendix D of the CSS 2.1
specification:
```css
table {display: table;}
tr {display: table-row;}
thead {display: table-header-group;}
tbody {display: table-row-group;}
tfoot {display: table-footer-group;}
col {display: table-column;}
colgroup {display: table-column-group;}
td, th {display: table-cell;}
caption {display: table-caption;}
```
In XML, where elements will not have display semantics by default, these values
become quite useful. Consider the following markup:
```html
<scores>
 <headers>
 <label>Team</label>
 <label>Score</label>
 </headers>
 <game sport="MLB" league="NL">
 <team>
 <name>Reds</name>
 <score>8</score>
 </team>
 <team>
 <name>Cubs</name>
 <score>5</score>
 </team>
 </game>
</scores>
```
This could be formatted in a tabular fashion using the following styles:
```css
scores {display: table;}
headers {display: table-header-group;}
game {display: table-row-group;}
team {display: table-row;}
label, name, score {display: table-cell;}
```
The various cells could then be styled as necessary—for example, boldfacing the
label elements and right-aligning the scores.

#### Row primacy

CSS defines its table model as “row primacy.” In other words, the model assumes that
authors will create markup languages where rows are explicitly declared. Columns,
on the other hand, are derived from the layout of the rows of cells. Thus, the first col‐
umn is made up of the first cells in each row; the second column is made up of the
second cells, and so forth.

Row primacy is not a major issue in HTML, where the markup language is already
row-oriented. In XML, it has more of an impact because it constrains the way in
which authors can define table markup. Because of the row-oriented nature of the
CSS table model, a markup language in which columns are the basis of table layout is
not really possible (assuming that the intent is to use CSS to present such
documents).

#### Columns

Although the CSS table model is row-oriented, columns do still play a part in layout.
A cell can belong to both contexts (row and column), even though it is descended
from row elements in the document source. In CSS, however, columns and column
groups can accept only four nontable properties: border, background, width, and
visibility.

In addition, each of these four properties has special rules that apply only in the col‐
umnar context:

`border`

Borders can be set for columns and column groups only if the property bordercollapse has the value collapse. In such circumstances, column and columngroup borders participate in the collapsing algorithm that sets the border styles at
each cell edge. (See “Collapsing Cell Borders” on page 749.)

`background`

The background of a column or column group will be visible only in cells where
both the cell and its row have transparent backgrounds. (See “Table Layers” on
page 742.)

`width`

The width property defines the minimum width of the column or column group.
The content of cells within the column (or group) may force the column to
become wider.

`visibility`

If the value of visibility for a column or column group is collapse, then none
of the cells in the column (or group) are rendered. Cells that span from the
collapsed column into other columns are clipped, as are cells that span from
other columns into the hidden column. Furthermore, the overall width of the
table is reduced by the width the column would have taken up. A declaration of
any visibility value other than hidden is ignored for a column or column
group.


### 14.1.3 Anonymous Table Objects

There is the possibility that a markup language might not contain enough elements to
fully represent tables as they are defined in CSS, or that an author will forget to
include all the necessary elements. For example, consider this HTML:
```html
<table>
 <td>Name:</td>
 <td><input type="text"></td>
</table>
```
You might glance at this markup and assume that it defines a two-cell table of a single
row, but structurally, there is no element defining a row (because the tr is missing).
To cover such possibilities, CSS defines a mechanism for inserting “missing” table
components as anonymous objects. For a basic example of how this works, let’s revisit
our missing-row HTML example. In CSS terms, what effectively happens is that an
anonymous table-row object is inserted between the table element and its descend‐
ant table cells:
```html
<table>
 <!--anonymous table-row object begins-->
 <td>Name:</td>
 <td><input type="text"></td>
 <!--anonymous table-row object ends-->
</table>
```
A visual representation of this process is given in Figure 14-2, where the dotted line
represents the inserted anonymous table row.


Figure 14-2. Anonymous-object generation in table formatting

Seven different kinds of anonymous-object insertions can occur in the CSS table
model. These seven rules are, like inheritance and specificity, an example of a mecha‐
nism that attempts to impose intuitive sense on the way CSS behaves.
#### Object insertion rules
1. If a table-cell element’s parent is not a table-row element, then an anonymous
table-row object is inserted between the table-cell element and its parent. The
inserted object will include all consecutive siblings of the table-cell element.
Consider the following styles and markup:
```css
system {display: table;}
name, moons {display: table-cell;}
```
```html
<system>
 <name>Mercury</name>
 <moons>0</moons>
</system>
```
The anonymous table-row object is inserted between the cell elements and the
system element, and it encloses both the name and moons elements.
The same holds true even if the parent element is a table-row-group. To extend
the example, assume that the following applies:
```csss
system {display: table;}
planet {display: table-row-group;}
name, moons {display: table-cell;}
```
```html
<system>
 <planet>
 <name>Mercury</name>
 <moons>0</moons>
 </planet>
 <planet>
 <name>Venus</name>
 <moons>0</moons>
 </planet>
</system>
```
In this example, both sets of cells will be enclosed in an anonymous table-row
object that is inserted between them and the planet elements.

2. If a table-row element’s parent is not a table, inline-table, or table-rowgroup element, then an anonymous table element is inserted between the
table-row element and its parent. The inserted object will include all consecutive
siblings of the table-row element. Consider the following styles and markup:
```css
docbody {display: block;}
planet {display: table-row;}
```
```html
<docbody>
 <planet>
 <name>Mercury</name>
 <moons>0</moons>
 </planet>
 <planet>
 <name>Venus</name>
 <moons>0</moons>
 </planet>
</docbody>
```
Because the display value of the planet elements’ parent is block, the anony‐
mous table object is inserted between the planet elements and the docbody ele‐
ment. This anonymous table object will enclose both planet elements, since
they are consecutive siblings.

3. If a table-column element’s parent is not a table, inline-table, or tablecolumn-group element, then an anonymous table element is inserted between
the table-column element and its parent. This is much the same as the tablerow rule just discussed, except for its column-oriented nature.

4. If the parent element of a table-row-group, table-header-group, tablefooter-group, table-column-group, or table-caption element is not a table
element, then an anonymous table object is inserted between the element and
its parent.

5. If a child element of a table or inline-table element is not a table-row-group,
table-header-group, table-footer-group, table-row, or table-caption ele‐
ment, then an anonymous table-row object is inserted between the table ele‐
ment and its child element. This anonymous object spans all of the consecutive
siblings of the child element that are not table-row-group, table-headergroup, table-footer-group, table-row, or table-caption elements. Consider
the following markup and styles:
```css
system {display: table;}
planet {display: table-row;}
name, moons {display: table-cell;}
```
```html
<system>
 <planet>
 <name>Mercury</name>
 <moons>0</moons>
 </planet>
 <name>Venus</name>
 <moons>0</moons>
</system>
```
Here, a single anonymous table-row object will be inserted between the system
element and the second set of name and moons elements. The planet element is
not enclosed by the anonymous object because its display is table-row.
6. If a child element of a table-row-group, table-header-group, or tablefooter-group element is not a table-row element, then an anonymous table
row object is inserted between the element and its child element. This anonymous
object spans all of the consecutive siblings of the child element that are not
table-row objects themselves. Consider the following markup and styles:
```css
system {display: table;}
planet {display: table-row-group;}
name, moons {display: table-cell;}
```
```html
<system>
 <planet>
 <name>Mercury</name>
 <moons>0</moons>
 </planet>
 <name>Venus</name>
 <moons>0</moons>
</system>
```
In this case, each set of name and moons elements will be enclosed in an anony‐
mous table-row element. For the second set, the insertion happens in accord
with rule 5. For the first set, the anonymous object is inserted between the planet
element and its children because the planet element is a table-row-group
element.
7. If a child element of a table-row element is not a table-cell element, then an
anonymous table-cell object is inserted between the element and its child ele‐
ment. This anonymous object encloses all consecutive siblings of the child ele‐
ment that are not table-cell elements themselves. Consider the following
markup and styles:
```css
system {display: table;}
planet {display: table-row;}
name, moons {display: table-cell;}
```
```html
<system>
 <planet>
 <name>Mercury</name>
 <num>0</num>
 </planet>
</system>
```
Because the element num does not have a table-related display value, an anony‐
mous table-cell object is inserted between the planet element and the num
element.
This behavior also extends to the encapsulation of anonymous inline boxes. Sup‐
pose that the num element was not included:
<system>
 <planet>
 <name>Mercury</name>
 0
 </planet>
</system>
The 0 would still be enclosed in an anonymous table-cell object. To further
illustrate this point, here is an example adapted from the CSS specification:
example {display: table-cell;}
row {display: table-row;}
hey {font-weight: 900;}
<example>
 <row>This is the <hey>top</hey> row.</row>
 <row>This is the <hey>bottom</hey> row.</row>
</example>
Within each row element, the text fragments and hey element are enclosed in
anonymous table-cell objects.

### 14.1.4 Table Layers

### 14.1.5 Captions

## 14.2 Table Cell Borders

### 14.2.1 Separated Cell Borders

### 14.2.2 Collapsing Cell Borders

## 14.3 Table Sizing

### 14.3.1 Width

### 14.3.2 Height

### 14.3.3 Alignment

## 14.4 Summary
